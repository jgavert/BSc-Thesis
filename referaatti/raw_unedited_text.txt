Michael A. Bender, Erik D. Demaine ja Martin Farach-Colton ovat kirjoittaneet artikkelin 'Cache-Oblivious B-Trees', joka on julkastu artikkelina SIAM Journal on Computing Vol 35. No 2. pp 341-358. Artikkelissa käsitellään välimuisti-riippumattomia tietorakenteita ja erityisesti miten he ovat saaneet tehtyä 2 välimuisti-riippumattomaa B-puuta.
	Ohjelmoinnin opiskelun alussa opetellaan myös tietorakenteita. Näissä tietorakenteissa puhutaan suoritusaika analyyseistä ja muistinkulutuksesta, mutta niissä on yleinen vika ja se johtuu siitä kuinka tietokoneet ovat kehittyneet. Aikaisemmin tietokoneissa ei ollut kuin välimuisti ja kovalevy, eli käsitellään 2-tasoisena muistihierarkiana. Nykyisissä koneissa on monia välimuistitasoja joka edellyttäisi, että ne pitäisi ottaa huomioon tietorakenteiden suunnittelussa. Myös tätä korostaa se, että eri välimuisti tasot ovat eri nopeuksisia joten välimuistien tehokas käyttö on haastavaa. (On olemassa välimuisti-malleja, jotka yrittävät ennakoida välimuistihierarkian vaikutuksen algoritmeihin, mutta nämä mallit olettavat muistinkannalta pullonkaulan olevan tiedossa.)
	Ratkaisu ongelmaan on välimuisti-riippumaton -malli. Mallin teoria perustuu ihanteelliseen-välimuisti malliin jossa käsitellään muistia kaksitasoisena muistihierarkiana, mutta malli toimii mille tahansa muistihierarkialle. (Frigo ja Prokop esittelivät tämän mallin papereissaan, joissa he esittelevät kuinka ongelmille kuten nopea Fourier muunnos ja matriisi kertolaskuun löytyy optimaaliset algoritmit jotka ovat välimuisti-riippumattomia. Nämä algoritmit suorittavat asymptoottisesti optimaalisen määrän muisti siirtoja millätahansa muistihierarkialla ja kaikilla tasoilla hierarkiassa.) Välimuisti-riippumattoman malli koostuu ideasta missä käsitellään 2-tasoista muistihierarkiaa. (Päämuisti on jaettu johonkin B määrään muistisoluihin ja välimuistilla on koko M ja se voi säilyttää M/B määrän muistilohkoja. M/B:n arvo on myös tarpeeksi suuri. M ja B arvot ovat tuntemattomia algoritmille tai tietorakenteelle.) Algoritmi  ei huolehdi muistista erityisesti. (Kun algoritmi yrittää päästä muistipaikkaan joka ei ole välimuistissa niin tällöin järjestelmä hakee kyseisen muistilohkon välimuistiin ja tätä kutsutaan muistisiirroksi. Jos välimuisti on täynnä niin korvataan muistin tulevaisuuden käytön kannalta optimaalisesti valittu muistilohko.) Frigo näyttää paperissaan, että näin voidaan simuloida mitä tahansa muistihierarkiaa( pienellä vakiokerroin overheadilla). Siis voidaan laskea välimuisti-riippumattomien mallien muistin käyttöä ihanteellisella-välimuisti mallilla.
	B-puun suunnittelu välimuisti-riippumattomaksi on hankalaa, koska puu itsessään on suunniteltu kaksitasoiselle muistihierarkialle. Joko optimoiduksi levylle kirjoituksia varten tai välimuistin kannalta. Tämän muuttaminen mille tahansa muistihierarkialle optimoiduksi on haaste.
	Välimuisti-riippumattoman mallin avulla voidaan ratkaista tämä ongelma. Kehitettiin 2 B-puuta seuraavilla muistisiirto rajoilla. Ensimmäinen puu sai haku operaation muistirajoiksi B-puun hakurajan. Päivitys operaation rajaksi saatiin sama kuin B-puiden raja, missä B-puun raja on pahin tapaus. Toisessa hakupuussa lisätään skannaus operaatio. Puun haku operaatio on edelleen sama kuin tyypillisen B-puun. Skannaus -operaatio saavutti optimaalisen muistikäytön. Päivitys operaatio sai rajan (INSERT ANALYZED MEMORY).
	Välimuisti-riippumaton puu on yksikertaisuudessaan AVL-puu missä sen N määrä elementtejä on jaettu ryhmiin joissa on O(log N) elementtiä. Ryhmät on tallennettu joukkoon jonka koko on myös O(log N). Jokainen elementti puussa siis pitää sisällään pointterin sitä vastaavaan ryhmä joukkoon ja toisinpäin. Mutta tämä johtaa siihen että etsiminen tässä puussa myös maksaa O(log N) muistisiirtoja. Tarkoituksena on että meillä on suhteellisen hitaat lisäykset ja poistot ylimmässä osaa puuta, mutta meillä pitäisi olla nopeat etsinnät.
	Yläpuun kompleksisuus halutaan pitää suurinpiirteisessä van Emde Boas -sommitelmassa. Van Emde Boas -sommitelma on käytännössä muokattu versio Prokopin sommitelmasta täydelliselle binääri puulle. Nimi tulee kuitenkin van Emde Boas tietorakenteesta, jota se muistuttaa. Van Emde Boas -sommitelman tärkeän ominaisuus on se että millä tahansa yksityiskohtaisella tasolla katsoessa, jokainen rekursiivinen alipuu on tallennettu jatkuvassa muistilohkossa. Jotta voidaan pitää yläpuun kompleksisuus van Emde Boas -sommitelmassa niin ensin käytetään paino-tasapainotettua B-puuta. Pitää siis staattinen sommitelma muuttaa dynaamiseksi. Käytetään avuksi dynaamisesti tasapainotetun hakupuun kahta tärkeätä ominaisuutta. Ensimmäinen on jälkeläisten jako pitääkseen elementit tasapainossa ja toiseksi tarvitaan vahvaa tasapainotusta. Jollekkin vakiolle d, jokaisessa elementissä v korkeudessa h on (O-)(d^h) jälkeläistä. Nämä kaksi ominaisuutta löytyy mm. tasapainotetusta B-puusta. ....
	Keskiosa puuta tallentaa edustuselementit alemmasta osasta puuta, joista osa voi olla kummitus elementtejä kuten myös keskitason elementeistä osa voi olla. Myös yläosassa puuta voi olla kummituselementtejä. Keskitaso on implementoitu yhtenä pakattuna-muisti rakenteena, missä edustus elementit toimivat ryhmien erottimina. Alempi puu on taas joukko pakattuja muisti rakenteita jos tarvitaan optimaalista skannaus operaatiota, muuten se voi olla implementoitu järjestämättöminä kokoelmina joukkoja. Näissä jokainen ryhmä on taas tallennettu muistiin jatkuvana osana jossain järjestyksessä. Nämä alueet on tallennettu muistiin saman kokoisina ja saa olla vakion verran tyhjänä. Lisäykset ja poistot joukoista tarkoittaa että koko joukko uudelleen kirjoitetaan. ....
